import { z } from "zod";
import { COOKIE_NAME } from "@shared/const";
import { getSessionCookieOptions } from "./_core/cookies";
import { systemRouter } from "./_core/systemRouter";
import { publicProcedure, protectedProcedure, router } from "./_core/trpc";
import * as db from "./db";
import * as receiving from "./modules/receiving";
import * as picking from "./modules/picking";
import * as locations from "./modules/locations";
import * as productsDb from "./modules/products";
import { parseNFeXML, validateNFeXML } from "./modules/nfeParser";
import { TRPCError } from "@trpc/server";
import * as divergenceApprovalsDb from "./modules/divergenceApprovals";
import { getDb } from "./db";
import { warehouseZones, warehouseLocations, receivingPreallocations, receivingOrders, products, inventory } from "../drizzle/schema";
import { eq, and, sql } from "drizzle-orm";

export const appRouter = router({
  system: systemRouter,
  
  auth: router({
    me: publicProcedure.query(opts => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return {
        success: true,
      } as const;
    }),
  }),

  // ============================================================================
  // TENANTS (CLIENTES)
  // ============================================================================
  
  tenants: router({
    list: protectedProcedure.query(async () => {
      return await db.getAllTenants();
    }),
    
    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        return await db.getTenantById(input.id);
      }),
    
    create: protectedProcedure
      .input(z.object({
        name: z.string().min(1),
        tradeName: z.string().optional(),
        cnpj: z.string().min(14),
        afe: z.string().optional(),
        ae: z.string().optional(),
        licenseNumber: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        zipCode: z.string().optional(),
        phone: z.string().optional(),
        email: z.string().email().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await db.createTenant(input);
        // MySQL retorna insertId em result[0].insertId
        const insertId = Number((result as any)[0]?.insertId || (result as any).insertId) || 0;
        
        // Criar log de auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_tenant",
          entityType: "tenant",
          entityId: insertId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, id: insertId };
      }),
    
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        name: z.string().min(1).optional(),
        tradeName: z.string().optional(),
        afe: z.string().optional(),
        ae: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        zipCode: z.string().optional(),
        phone: z.string().optional(),
        email: z.string().email().optional(),
        status: z.enum(["active", "inactive", "suspended"]).optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { id, ...data } = input;
        const oldValue = await db.getTenantById(id);
        
        await db.updateTenant(id, data);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "update_tenant",
          entityType: "tenant",
          entityId: id,
          oldValue: JSON.stringify(oldValue),
          newValue: JSON.stringify(data),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),
    
    delete: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await db.getTenantById(input.id);
        
        await db.deleteTenant(input.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_tenant",
          entityType: "tenant",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),

    deleteMany: protectedProcedure
      .input(z.object({ ids: z.array(z.number()) }))
      .mutation(async ({ input, ctx }) => {
        let deletedCount = 0;
        for (const id of input.ids) {
          try {
            const oldValue = await db.getTenantById(id);
            await db.deleteTenant(id);
            
            await db.createAuditLog({
              userId: ctx.user.id,
              action: "delete_tenant",
              entityType: "tenant",
              entityId: id,
              oldValue: JSON.stringify(oldValue),
              ipAddress: ctx.req.ip,
              userAgent: ctx.req.headers["user-agent"],
            });
            deletedCount++;
          } catch (error) {
            // Continua deletando os outros mesmo se um falhar
            console.error(`Erro ao deletar tenant ${id}:`, error);
          }
        }
        
        return { success: true, deletedCount };
      }),
  }),

  // ============================================================================
  // CONTRACTS
  // ============================================================================
  
  contracts: router({
    listByTenant: protectedProcedure
      .input(z.object({ tenantId: z.number() }))
      .query(async ({ input }) => {
        return await db.getContractsByTenant(input.tenantId);
      }),
    
    create: protectedProcedure
      .input(z.object({
        tenantId: z.number(),
        contractNumber: z.string().min(1),
        startDate: z.date(),
        endDate: z.date().optional(),
        slaReceivingHours: z.number().optional(),
        slaPickingHours: z.number().optional(),
        slaShippingHours: z.number().optional(),
        pickingStrategy: z.enum(["FEFO", "FIFO", "LIFO"]).optional(),
        expiryDaysThreshold: z.number().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await db.createContract(input);
        // MySQL retorna insertId em result[0].insertId
        const insertId = Number((result as any)[0]?.insertId || (result as any).insertId) || 0;
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_contract",
          entityType: "contract",
          entityId: insertId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, id: insertId };
      }),
  }),

  // ============================================================================
  // PRODUCTS
  // ============================================================================
  
  products: router({
    list: protectedProcedure
      .input(z.object({ tenantId: z.number().optional() }).optional())
      .query(async ({ input }) => {
        return await db.getAllProducts(input?.tenantId);
      }),
    
    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        return await db.getProductById(input.id);
      }),
    
    create: protectedProcedure
      .input(z.object({
        tenantId: z.number(),
        sku: z.string().min(1),
        description: z.string().min(1),
        gtin: z.string().optional(),
        anvisaRegistry: z.string().optional(),
        therapeuticClass: z.string().optional(),
        manufacturer: z.string().optional(),
        unitOfMeasure: z.string().default("UN"),
        unitsPerBox: z.number().optional(),
        requiresBatchControl: z.boolean().default(true),
        requiresExpiryControl: z.boolean().default(true),
        requiresSerialControl: z.boolean().default(false),
        storageCondition: z.enum(["ambient", "refrigerated_2_8", "frozen_minus_20", "controlled"]).default("ambient"),
        minTemperature: z.string().optional(),
        maxTemperature: z.string().optional(),
        requiresHumidityControl: z.boolean().default(false),
        isControlledSubstance: z.boolean().default(false),
        isPsychotropic: z.boolean().default(false),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await db.createProduct(input);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_product",
          entityType: "product",
          entityId: Number((result as any).insertId),
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, id: Number((result as any).insertId) };
      }),
    
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        description: z.string().min(1).optional(),
        gtin: z.string().optional(),
        anvisaRegistry: z.string().optional(),
        therapeuticClass: z.string().optional(),
        manufacturer: z.string().optional(),
        unitsPerBox: z.number().optional(),
        storageCondition: z.enum(["ambient", "refrigerated_2_8", "frozen_minus_20", "controlled"]).optional(),
        status: z.enum(["active", "inactive", "discontinued"]).optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { id, ...data } = input;
        const oldValue = await db.getProductById(id);
        
        await db.updateProduct(id, data);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "update_product",
          entityType: "product",
          entityId: id,
          oldValue: JSON.stringify(oldValue),
          newValue: JSON.stringify(data),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),
    
    delete: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await db.getProductById(input.id);
        
        await db.deleteProduct(input.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_product",
          entityType: "product",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),

    deleteMany: protectedProcedure
      .input(z.object({ ids: z.array(z.number()) }))
      .mutation(async ({ input, ctx }) => {
        let deletedCount = 0;
        for (const id of input.ids) {
          try {
            const oldValue = await db.getProductById(id);
            await db.deleteProduct(id);
            
            await db.createAuditLog({
              userId: ctx.user.id,
              action: "delete_product",
              entityType: "product",
              entityId: id,
              oldValue: JSON.stringify(oldValue),
              ipAddress: ctx.req.ip,
              userAgent: ctx.req.headers["user-agent"],
            });
            deletedCount++;
          } catch (error) {
            console.error(`Erro ao deletar produto ${id}:`, error);
          }
        }
        
        return { success: true, deletedCount };
      }),
  }),

  // ============================================================================
  // RECEIVING
  // ============================================================================
  
  receiving: router({
    list: protectedProcedure
      .input(z.object({ tenantId: z.number().optional() }).optional())
      .query(async ({ input }) => {
        return await db.getAllReceivingOrders(input?.tenantId);
      }),
    
    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        return await receiving.getReceivingOrderById(input.id);
      }),
    
    getItems: protectedProcedure
      .input(z.object({ receivingOrderId: z.number() }))
      .query(async ({ input }) => {
        return await receiving.getReceivingOrderItems(input.receivingOrderId);
      }),
    
    create: protectedProcedure
      .input(z.object({
        tenantId: z.number(),
        orderNumber: z.string().min(1),
        nfeKey: z.string().optional(),
        nfeNumber: z.string().optional(),
        supplierName: z.string().optional(),
        supplierCnpj: z.string().optional(),
        scheduledDate: z.date().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await db.createReceivingOrder({
          ...input,
          createdBy: ctx.user.id,
        });
        // MySQL retorna insertId em result[0].insertId
        const insertId = Number((result as any)[0]?.insertId || (result as any).insertId) || 0;
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_receiving_order",
          entityType: "receiving_order",
          entityId: insertId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, id: insertId };
      }),
    
    importNFe: protectedProcedure
      .input(z.object({
        tenantId: z.number(),
        xmlContent: z.string(),
        operationType: z.enum(["entrada", "saida", "logistica_reversa"]),
        forceReimport: z.boolean().optional().default(false),
      }))
      .mutation(async ({ input, ctx }) => {
        // Validar se tenant existe
        const tenant = await db.getTenantById(input.tenantId);
        if (!tenant) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: `Cliente com ID ${input.tenantId} não encontrado`,
          });
        }
        
        // Validar XML
        const validation = validateNFeXML(input.xmlContent);
        if (!validation.valid) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: validation.error || "XML inválido",
          });
        }
        
        // Fazer parse do XML
        const nfeData = parseNFeXML(input.xmlContent);
        
        let orderId = 0;
        let orderType = "";
        
        // Fluxo 1: ENTRADA - Gera OT de Recebimento
        if (input.operationType === "entrada") {
          // Alocar automaticamente endereço REC
          const receivingLocationModule = await import("./receiving-location");
          const receivingLocationId = await receivingLocationModule.allocateReceivingLocation(
            input.tenantId
          );
          
          // Verificar se já existe ordem com este número
          const dbConn = await getDb();
          if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
          
          const existingOrder = await dbConn
            .select({ id: receivingOrders.id, orderNumber: receivingOrders.orderNumber })
            .from(receivingOrders)
            .where(eq(receivingOrders.orderNumber, `REC-${nfeData.nfeNumber}`))
            .limit(1);
          
          if (existingOrder.length > 0) {
            if (!input.forceReimport) {
              // Retornar erro especial indicando duplicata
              throw new TRPCError({
                code: "CONFLICT",
                message: `DUPLICATE_ORDER:${existingOrder[0].id}:${existingOrder[0].orderNumber}`,
              });
            }
            
            // Forçar reimportação: deletar ordem antiga
            console.log(`[NF-e Import] Forçando reimportação - deletando ordem ${existingOrder[0].id}`);
            
            await receiving.deleteReceivingOrder(existingOrder[0].id);
            
            await db.createAuditLog({
              userId: ctx.user.id,
              action: "force_reimport_nfe",
              entityType: "receiving_order",
              entityId: existingOrder[0].id,
              oldValue: JSON.stringify({ orderNumber: existingOrder[0].orderNumber }),
              newValue: JSON.stringify({ nfeKey: nfeData.nfeKey }),
              ipAddress: ctx.req.ip,
              userAgent: ctx.req.headers["user-agent"],
            });
          }
          
          console.log(`[NF-e Import] Creating receiving order with:`, {
            tenantId: input.tenantId,
            tenantIdType: typeof input.tenantId,
            receivingLocationId,
            receivingLocationIdType: typeof receivingLocationId,
            orderNumber: `REC-${nfeData.nfeNumber}`,
          });
          
          const orderResult = await db.createReceivingOrder({
            tenantId: Number(input.tenantId), // Garantir que é número
            orderNumber: `REC-${nfeData.nfeNumber}`,
            nfeKey: nfeData.nfeKey,
            nfeNumber: nfeData.nfeNumber,
            supplierName: nfeData.supplier.name,
            supplierCnpj: nfeData.supplier.cnpj,
            scheduledDate: nfeData.issueDate,
            receivingLocationId: Number(receivingLocationId), // Garantir que é número
            createdBy: ctx.user.id,
          });
          
          orderId = Number((orderResult as any)[0]?.insertId || (orderResult as any).insertId) || 0;
          orderType = "receiving_order";
          
          if (orderId === 0) {
            throw new TRPCError({
              code: "INTERNAL_SERVER_ERROR",
              message: "Erro ao criar ordem de recebimento",
            });
          }
          
          // Criar itens da ordem com dados esperados da NF-e
          for (const item of nfeData.items) {
            // Buscar ou criar produto automaticamente
            let productId: number;
            
            // Tentar buscar produto existente por GTIN ou código interno
            const existingProduct = await productsDb.findProductBySkuOrGtin(
              item.productCode,
              item.gtin || ""
            );
            
            if (existingProduct) {
              productId = existingProduct.id;
              console.log(`[NF-e Import] Produto existente encontrado: ${existingProduct.sku} (ID: ${productId})`);
            } else {
              // Criar produto automaticamente
              console.log(`[NF-e Import] Criando novo produto: ${item.productCode} - ${item.productDescription}`);
              
              try {
                const newProduct = await productsDb.createProduct({
                  tenantId: input.tenantId,
                  sku: item.productCode, // cProd
                  description: item.productDescription, // xProd
                  gtin: item.gtin || undefined, // cEAN
                  unitOfMeasure: item.unitOfMeasure || "UN",
                  requiresBatchControl: true,
                  requiresExpiryControl: true,
                  requiresSerialControl: false,
                  storageCondition: "ambient",
                });
                
                productId = newProduct.id;
                console.log(`[NF-e Import] Produto criado com sucesso: ${newProduct.sku} (ID: ${productId})`);
              } catch (error) {
                console.error(`[NF-e Import] Erro ao criar produto:`, error);
                throw new TRPCError({
                  code: "INTERNAL_SERVER_ERROR",
                  message: `Erro ao criar produto ${item.productCode}: ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
                });
              }
            }
            
            await receiving.createReceivingOrderItem({
              receivingOrderId: orderId,
              productId,
              expectedQuantity: item.quantity,
              expectedGtin: item.gtin,
              expectedSupplierCode: item.productCode,
              expectedInternalCode: item.productCode,
              batch: item.batch,
              expiryDate: item.expiryDate,
            });
          }
        }
        
        // Fluxo 2: SAÍDA - Gera OT de Picking/Separação
        else if (input.operationType === "saida") {
          const orderResult = await picking.createPickingOrder({
            tenantId: input.tenantId,
            orderNumber: `PICK-${nfeData.nfeNumber}`,
            customerName: nfeData.supplier.name,
            deliveryAddress: "",
            priority: "normal",
            createdBy: ctx.user.id,
          });
          
          orderId = Number((orderResult as any)[0]?.insertId || (orderResult as any).insertId) || 0;
          orderType = "picking_order";
          
          if (orderId === 0) {
            throw new TRPCError({
              code: "INTERNAL_SERVER_ERROR",
              message: "Erro ao criar ordem de picking",
            });
          }
          
          // Criar itens da ordem de picking
          for (const item of nfeData.items) {
            await picking.createPickingOrderItem({
              pickingOrderId: orderId,
              productId: 1, // TODO: Buscar produto por SKU/GTIN
              requestedQuantity: item.quantity,
            });
          }
        }
        
        // Fluxo 3: LOGÍSTICA REVERSA - Gera processo de quarentena/descarte
        else if (input.operationType === "logistica_reversa") {
          // TODO: Implementar tabela e lógica de logística reversa
          // Por enquanto, criar como ordem de recebimento com status especial
          const orderResult = await db.createReceivingOrder({
            tenantId: input.tenantId,
            orderNumber: `REV-${nfeData.nfeNumber}`,
            nfeKey: nfeData.nfeKey,
            nfeNumber: nfeData.nfeNumber,
            supplierName: nfeData.supplier.name,
            supplierCnpj: nfeData.supplier.cnpj,
            scheduledDate: nfeData.issueDate,
            createdBy: ctx.user.id,
          });
          
          orderId = Number((orderResult as any)[0]?.insertId || (orderResult as any).insertId) || 0;
          orderType = "reverse_logistics";
          
          if (orderId === 0) {
            throw new TRPCError({
              code: "INTERNAL_SERVER_ERROR",
              message: "Erro ao criar processo de logística reversa",
            });
          }
          
          // Criar itens com status de quarentena
          for (const item of nfeData.items) {
            await receiving.createReceivingOrderItem({
              receivingOrderId: orderId,
              productId: 1,
              expectedQuantity: item.quantity,
              expectedGtin: item.gtin,
              expectedSupplierCode: item.productCode,
              expectedInternalCode: item.productCode,
              batch: item.batch,
              expiryDate: item.expiryDate,
              status: "in_quarantine", // Status especial para logística reversa
            });
          }
        }
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "import_nfe",
          entityType: orderType,
          entityId: orderId,
          newValue: JSON.stringify({ 
            nfeKey: nfeData.nfeKey, 
            itemCount: nfeData.items.length,
            operationType: input.operationType 
          }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { 
          success: true, 
          id: orderId, 
          orderType: input.operationType,
          nfeData 
        };
      }),
    
    checkItem: protectedProcedure
      .input(z.object({
        itemId: z.number(),
        receivedQuantity: z.number(),
        productCode: z.string().optional(),
        supplierCode: z.string().optional(),
        internalCode: z.string().optional(),
        batch: z.string().optional(),
        expiryDate: z.string().optional(),
        serialNumber: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        // Buscar item para verificar divergência
        const item = await receiving.getReceivingOrderItemById(input.itemId);
        
        if (!item) {
          throw new TRPCError({
            code: "NOT_FOUND",
            message: "Item não encontrado",
          });
        }
        
        // Verificar divergências críticas
        const quantityDifference = Math.abs(input.receivedQuantity - item.expectedQuantity);
        const quantityPercentDiff = item.expectedQuantity > 0 
          ? (quantityDifference / item.expectedQuantity) * 100 
          : 0;
        
        const hasQuantityDivergence = quantityDifference > 0 && 
          (quantityPercentDiff > 10 || quantityDifference > 5);
        
        const hasCodeDivergence = 
          (item.expectedGtin && input.productCode && item.expectedGtin !== input.productCode) ||
          (item.expectedSupplierCode && input.supplierCode && item.expectedSupplierCode !== input.supplierCode) ||
          (item.expectedInternalCode && input.internalCode && item.expectedInternalCode !== input.internalCode);
        
        const hasCriticalDivergence = hasQuantityDivergence || hasCodeDivergence;
        
        // Determinar status: se não há divergência crítica, aprovar automaticamente
        const newStatus = hasCriticalDivergence ? "pending" : "approved";
        
        // Atualizar item com dados conferidos
        await receiving.updateReceivingOrderItem(input.itemId, {
          receivedQuantity: input.receivedQuantity,
          scannedGtin: input.productCode,
          scannedSupplierCode: input.supplierCode,
          scannedInternalCode: input.internalCode,
          batch: input.batch,
          expiryDate: input.expiryDate ? new Date(input.expiryDate) : undefined,
          serialNumber: input.serialNumber,
          status: newStatus,
        });
        
        // Se aprovado automaticamente, alocar em endereço de recebimento
        if (newStatus === "approved") {
          const dbConn = await getDb();
          if (dbConn) {
            // Buscar zona de Recebimento
            const zones = await dbConn.select().from(warehouseZones).where(eq(warehouseZones.code, "REC"));
            const recZone = zones?.[0];
            
            if (recZone) {
              // Buscar primeiro endereço disponível na zona de recebimento
              const availableLocations = await dbConn.select()
                .from(warehouseLocations)
                .where(and(
                  eq(warehouseLocations.zoneId, recZone.id),
                  eq(warehouseLocations.status, "available")
                ))
                .limit(1);
              
              const location = availableLocations?.[0];
              
              if (location) {
                // Atualizar status do endereço para ocupado
                await dbConn.update(warehouseLocations)
                  .set({ status: "occupied", updatedAt: new Date() })
                  .where(eq(warehouseLocations.id, location.id));
                
                // TODO: Criar registro de movimentação de estoque com location.id
                // Por enquanto, apenas registrar no log
              }
            }
          }
        }
        
        // Registrar log de auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "check_receiving_item",
          entityType: "receiving_item",
          entityId: input.itemId,
          oldValue: JSON.stringify({ expectedQuantity: item.expectedQuantity }),
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { 
          success: true, 
          divergent: input.receivedQuantity !== item.expectedQuantity,
          difference: input.receivedQuantity - item.expectedQuantity,
          hasCriticalDivergence,
          status: newStatus,
        };
      }),
    
    validateItem: protectedProcedure
      .input(z.object({
        itemId: z.number(),
        receivedQuantity: z.number(),
        batch: z.string(),
        expiryDate: z.date(),
        serialNumber: z.string().optional(),
      }))
      .mutation(async ({ input }) => {
        return await receiving.validateReceivingItem(
          input.itemId,
          input.receivedQuantity,
          input.batch,
          input.expiryDate,
          input.serialNumber
        );
      }),
    
    moveToQuarantine: protectedProcedure
      .input(z.object({
        receivingOrderId: z.number(),
        itemId: z.number(),
        quantity: z.number(),
        batch: z.string(),
        expiryDate: z.date(),
        serialNumber: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await receiving.moveToQuarantine(
          input.receivingOrderId,
          input.itemId,
          input.quantity,
          input.batch,
          input.expiryDate,
          input.serialNumber,
          ctx.user.id
        );
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "move_to_quarantine",
          entityType: "receiving_order_item",
          entityId: input.itemId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    approveQuarantine: protectedProcedure
      .input(z.object({
        itemId: z.number(),
        signature: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await receiving.approveQuarantine(
          input.itemId,
          ctx.user.id,
          input.signature
        );
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "approve_quarantine",
          entityType: "receiving_order_item",
          entityId: input.itemId,
          newValue: JSON.stringify({ signature: input.signature }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    rejectQuarantine: protectedProcedure
      .input(z.object({
        itemId: z.number(),
        reason: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await receiving.rejectQuarantine(
          input.itemId,
          ctx.user.id,
          input.reason
        );
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "reject_quarantine",
          entityType: "receiving_order_item",
          entityId: input.itemId,
          newValue: JSON.stringify({ reason: input.reason }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    delete: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input, ctx }) => {
        await receiving.deleteReceivingOrder(input.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_receiving_order",
          entityType: "receiving_order",
          entityId: input.id,
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),
    
    deleteBatch: protectedProcedure
      .input(z.object({ ids: z.array(z.number()) }))
      .mutation(async ({ input, ctx }) => {
        await receiving.deleteReceivingOrders(input.ids);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_receiving_orders_batch",
          entityType: "receiving_order",
          entityId: 0,
          newValue: JSON.stringify({ deletedIds: input.ids }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, count: input.ids.length };
      }),
    
    // Pré-alocação de endereços via planilha Excel
    downloadPreallocationTemplate: protectedProcedure
      .query(async () => {
        const { generateTemplateExcel } = await import("./preallocation");
        
        // Gerar arquivo modelo
        const buffer = generateTemplateExcel();
        
        // Retornar como base64 para o frontend
        return {
          fileBase64: buffer.toString('base64'),
          filename: 'modelo-preallocacao.xlsx',
        };
      }),
    
    uploadPreallocationFile: protectedProcedure
      .input(z.object({
        receivingOrderId: z.number(),
        tenantId: z.number(),
        fileBase64: z.string(), // Arquivo Excel em base64
      }))
      .mutation(async ({ input, ctx }) => {
        const { processPreallocationExcel, validatePreallocations } = await import("./preallocation");
        
        // Decodificar arquivo
        const fileBuffer = Buffer.from(input.fileBase64, 'base64');
        
        // Processar planilha
        const { rows, errors: parseErrors } = await processPreallocationExcel(fileBuffer);
        
        if (parseErrors.length > 0) {
          return {
            success: false,
            errors: parseErrors,
            validations: [],
          };
        }
        
        // Validar contra banco de dados
        const validations = await validatePreallocations(rows, input.tenantId);
        
        return {
          success: true,
          errors: [],
          validations,
        };
      }),
    
    savePreallocations: protectedProcedure
      .input(z.object({
        receivingOrderId: z.number(),
        validations: z.array(z.object({
          isValid: z.boolean(),
          row: z.number(),
          endereco: z.string(),
          codInterno: z.string(),
          lote: z.string(),
          quantidade: z.number(),
          errors: z.array(z.string()),
          locationId: z.number().optional(),
          productId: z.number().optional(),
        })),
      }))
      .mutation(async ({ input, ctx }) => {
        const { savePreallocations } = await import("./preallocation");
        
        const savedCount = await savePreallocations(
          input.receivingOrderId,
          input.validations,
          ctx.user.id
        );
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "save_preallocations",
          entityType: "receiving_order",
          entityId: input.receivingOrderId,
          newValue: JSON.stringify({ count: savedCount }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, count: savedCount };
      }),
    
    getPreallocations: protectedProcedure
      .input(z.object({ receivingOrderId: z.number() }))
      .query(async ({ input }) => {
        const dbConn = await getDb();
        if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
        
        const preallocations = await dbConn
          .select({
            id: receivingPreallocations.id,
            productId: receivingPreallocations.productId,
            locationId: receivingPreallocations.locationId,
            batch: receivingPreallocations.batch,
            quantity: receivingPreallocations.quantity,
            status: receivingPreallocations.status,
            productSku: products.sku,
            productDescription: products.description,
            locationCode: warehouseLocations.code,
          })
          .from(receivingPreallocations)
          .leftJoin(products, eq(receivingPreallocations.productId, products.id))
          .leftJoin(warehouseLocations, eq(receivingPreallocations.locationId, warehouseLocations.id))
          .where(eq(receivingPreallocations.receivingOrderId, input.receivingOrderId));
        
        return preallocations;
      }),
    
    getSuggestedLocation: protectedProcedure
      .input(z.object({
        productId: z.number(),
        batch: z.string(),
        quantity: z.number(),
        tenantId: z.number(),
      }))
      .query(async ({ input }) => {
        const dbConn = await getDb();
        if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
        
        // Prioridade 1: Buscar pré-alocação
        console.log(`[Suggestion] Searching preallocation for productId=${input.productId}, batch=${input.batch}, tenantId=${input.tenantId}`);
        
        const preallocation = await dbConn
          .select({
            locationId: receivingPreallocations.locationId,
            locationCode: warehouseLocations.code,
            quantity: receivingPreallocations.quantity,
            status: receivingPreallocations.status,
          })
          .from(receivingPreallocations)
          .leftJoin(warehouseLocations, eq(receivingPreallocations.locationId, warehouseLocations.id))
          .leftJoin(receivingOrders, eq(receivingPreallocations.receivingOrderId, receivingOrders.id))
          .where(
            and(
              eq(receivingPreallocations.productId, input.productId),
              eq(receivingPreallocations.batch, input.batch),
              eq(receivingPreallocations.status, "pending"),
              eq(receivingOrders.tenantId, input.tenantId)
            )
          )
          .limit(1);
        
        console.log(`[Suggestion] Preallocation query result:`, JSON.stringify(preallocation));
        
        if (preallocation.length > 0 && preallocation[0].locationId && preallocation[0].locationCode) {
          console.log(`[Suggestion] Found preallocation: ${preallocation[0].locationCode}`);
          return {
            locationId: preallocation[0].locationId,
            locationCode: preallocation[0].locationCode,
            source: "preallocation" as const,
          };
        }
        
        // Prioridade 2: Buscar endereço livre do cliente
        const freeLocation = await dbConn
          .select({
            id: warehouseLocations.id,
            code: warehouseLocations.code,
          })
          .from(warehouseLocations)
          .where(
            and(
              eq(warehouseLocations.tenantId, input.tenantId),
              eq(warehouseLocations.status, "available")
            )
          )
          .limit(1);
        
        if (freeLocation.length > 0) {
          console.log(`[Suggestion] Found free location: ${freeLocation[0].code}`);
          return {
            locationId: freeLocation[0].id,
            locationCode: freeLocation[0].code,
            source: "free" as const,
          };
        }
        
        console.log(`[Suggestion] No suggestion found`);
        return null;
      }),
    
    generateLabels: protectedProcedure
      .input(z.object({ receivingOrderId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const { generateLocationLabelsPDF, translateLocationType } = await import("./labelGenerator");
        
        const dbConn = await getDb();
        if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
        
        // Buscar ordem de recebimento
        const order = await receiving.getReceivingOrderById(input.receivingOrderId);
        if (!order) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Ordem de recebimento não encontrada" });
        }
        
        // Buscar pré-alocações com joins
        const preallocationsRaw = await dbConn
          .select()
          .from(receivingPreallocations)
          .leftJoin(warehouseLocations, eq(receivingPreallocations.locationId, warehouseLocations.id))
          .leftJoin(warehouseZones, eq(warehouseLocations.zoneId, warehouseZones.id))
          .where(eq(receivingPreallocations.receivingOrderId, input.receivingOrderId));
        
        const preallocations = preallocationsRaw.map(row => ({
          locationCode: row.warehouseLocations?.code || "",
          zoneName: row.warehouseZones?.name || null,
          locationType: row.warehouseLocations?.locationType || null,
        }));
        
        // Buscar endereços de recebimento (REC01-REC10) do tenant
        const recLocationsRaw = await dbConn
          .select()
          .from(warehouseLocations)
          .leftJoin(warehouseZones, eq(warehouseLocations.zoneId, warehouseZones.id))
          .where(eq(warehouseZones.code, "REC"))
          .limit(10);
        
        const recLocations = recLocationsRaw.map(row => ({
          code: row.warehouseLocations.code,
          zoneName: row.warehouseZones?.name || null,
          locationType: row.warehouseLocations.locationType,
        }));
        
        // Lógica de etiquetas:
        // - SE houver pré-alocação: imprimir APENAS endereços pré-alocados
        // - SE NÃO houver pré-alocação: imprimir endereços de recebimento
        let labels;
        
        if (preallocations.length > 0) {
          // Usar APENAS endereços pré-alocados
          labels = preallocations.map(loc => ({
            code: loc.locationCode || "",
            zone: loc.zoneName || undefined,
            type: loc.locationType ? translateLocationType(loc.locationType) : undefined,
            description: "Endereço Pré-alocado",
          }));
        } else {
          // Fallback: usar endereços de recebimento
          labels = recLocations.map(loc => ({
            code: loc.code,
            zone: loc.zoneName || undefined,
            type: loc.locationType ? translateLocationType(loc.locationType) : undefined,
            description: "Endereço de Recebimento",
          }));
        }
        
        if (labels.length === 0) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: `Nenhuma etiqueta para gerar. Verifique se existem endereços de recebimento (zona REC) cadastrados para o cliente ou adicione pré-alocações.`,
          });
        }
        
        // Log para debug
        if (preallocations.length > 0) {
          console.log(`[Etiquetas] Gerando ${preallocations.length} etiquetas pré-alocadas para ordem ${input.receivingOrderId}`);
        } else {
          console.log(`[Etiquetas] Gerando ${recLocations.length} etiquetas de recebimento para ordem ${input.receivingOrderId}`);
        }
        
        // Gerar PDF
        const pdfBuffer = await generateLocationLabelsPDF(labels);
        
        // Registrar no histórico de impressões
        const { labelPrintHistory } = await import("../drizzle/schema");
        await dbConn.insert(labelPrintHistory).values({
          tenantId: order.tenantId,
          userId: ctx.user?.id || 0,
          receivingOrderId: input.receivingOrderId,
          nfeNumber: order.nfeNumber,
          labelCount: labels.length,
          labelData: JSON.stringify(labels),
        });
        
        console.log(`[Etiquetas] Histórico registrado: ${labels.length} etiquetas para ordem ${input.receivingOrderId}`);
        
        return {
          success: true,
          pdfBase64: pdfBuffer.toString("base64"),
          labelCount: labels.length,
        };
      }),
    
    getLabelPrintHistory: protectedProcedure
      .input(z.object({
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        userId: z.number().optional(),
        receivingOrderId: z.number().optional(),
      }).optional())
      .query(async ({ input }) => {
        const { labelPrintHistory, users, receivingOrders } = await import("../drizzle/schema");
        const dbConn = await getDb();
        if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
        
        let query = dbConn
          .select({
            id: labelPrintHistory.id,
            tenantId: labelPrintHistory.tenantId,
            userId: labelPrintHistory.userId,
            userName: users.name,
            receivingOrderId: labelPrintHistory.receivingOrderId,
            orderNumber: receivingOrders.orderNumber,
            nfeNumber: labelPrintHistory.nfeNumber,
            labelCount: labelPrintHistory.labelCount,
            labelData: labelPrintHistory.labelData,
            createdAt: labelPrintHistory.createdAt,
          })
          .from(labelPrintHistory)
          .leftJoin(users, eq(labelPrintHistory.userId, users.id))
          .leftJoin(receivingOrders, eq(labelPrintHistory.receivingOrderId, receivingOrders.id))
          .orderBy(sql`${labelPrintHistory.createdAt} DESC`);
        
        // Aplicar filtros se fornecidos
        const filters = [];
        if (input?.startDate) {
          filters.push(sql`${labelPrintHistory.createdAt} >= ${input.startDate}`);
        }
        if (input?.endDate) {
          filters.push(sql`${labelPrintHistory.createdAt} <= ${input.endDate}`);
        }
        if (input?.userId) {
          filters.push(eq(labelPrintHistory.userId, input.userId));
        }
        if (input?.receivingOrderId) {
          filters.push(eq(labelPrintHistory.receivingOrderId, input.receivingOrderId));
        }
        
        if (filters.length > 0) {
          query = query.where(and(...filters)) as any;
        }
        
        return await query;
      }),
    
    reprintLabels: protectedProcedure
      .input(z.object({ historyId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const { labelPrintHistory } = await import("../drizzle/schema");
        const { generateLocationLabelsPDF } = await import("./labelGenerator");
        const dbConn = await getDb();
        if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database not available" });
        
        // Buscar registro de histórico
        const history = await dbConn
          .select()
          .from(labelPrintHistory)
          .where(eq(labelPrintHistory.id, input.historyId))
          .limit(1);
        
        if (history.length === 0) {
          throw new TRPCError({ code: "NOT_FOUND", message: "Registro de impressão não encontrado" });
        }
        
        const record = history[0];
        const labels = JSON.parse(record.labelData);
        
        // Gerar PDF novamente
        const pdfBuffer = await generateLocationLabelsPDF(labels);
        
        // Registrar nova impressão no histórico
        await dbConn.insert(labelPrintHistory).values({
          tenantId: record.tenantId,
          userId: ctx.user?.id || 0,
          receivingOrderId: record.receivingOrderId,
          nfeNumber: record.nfeNumber,
          labelCount: labels.length,
          labelData: record.labelData,
        });
        
        console.log(`[Etiquetas] Reimpressão registrada: ${labels.length} etiquetas (histórico #${input.historyId})`);
        
        return {
          success: true,
          pdfBase64: pdfBuffer.toString("base64"),
          labelCount: labels.length,
        };
      }),
    
    // Conferência Parcial
    registerConference: protectedProcedure
      .input(z.object({
        receivingOrderItemId: z.number(),
        batch: z.string().nullable(),
        quantityConferenced: z.number().min(1),
        notes: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user) {
          throw new TRPCError({ code: "UNAUTHORIZED", message: "Usuário não autenticado" });
        }
        
        const conference = await import("./conference");
        return await conference.registerPartialConference({
          ...input,
          conferencedBy: ctx.user.id,
        });
      }),
    
    getConferenceHistory: protectedProcedure
      .input(z.object({ receivingOrderItemId: z.number() }))
      .query(async ({ input }) => {
        const conference = await import("./conference");
        return await conference.getConferenceHistory(input.receivingOrderItemId);
      }),
    
    getPendingBalance: protectedProcedure
      .input(z.object({ receivingOrderItemId: z.number() }))
      .query(async ({ input }) => {
        const conference = await import("./conference");
        return await conference.getPendingBalance(input.receivingOrderItemId);
      }),
    
    // Divergências
    registerDivergence: protectedProcedure
      .input(z.object({
        receivingOrderItemId: z.number(),
        batch: z.string().nullable(),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user) {
          throw new TRPCError({ code: "UNAUTHORIZED", message: "Usuário não autenticado" });
        }
        
        const conference = await import("./conference");
        return await conference.registerDivergence({
          ...input,
          reportedBy: ctx.user.id,
        });
      }),
    
    approveDivergence: protectedProcedure
      .input(z.object({
        divergenceId: z.number(),
        justification: z.string().min(1),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user) {
          throw new TRPCError({ code: "UNAUTHORIZED", message: "Usuário não autenticado" });
        }
        
        // Validar se é admin
        if (ctx.user.role !== "admin") {
          throw new TRPCError({
            code: "FORBIDDEN",
            message: "Apenas supervisores (admin) podem aprovar divergências",
          });
        }
        
        const conference = await import("./conference");
        return await conference.approveDivergence({
          ...input,
          approvedBy: ctx.user.id,
        });
      }),
    
    getPendingDivergences: protectedProcedure
      .input(z.object({ tenantId: z.number().optional() }).optional())
      .query(async ({ input }) => {
        const conference = await import("./conference");
        return await conference.getPendingDivergences(input?.tenantId);
      }),
    
    // Endereçamento
    addressItem: protectedProcedure
      .input(z.object({
        receivingOrderItemId: z.number(),
        locationId: z.number(),
        quantity: z.number().min(1),
        batch: z.string(),
        expiryDate: z.date(),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user) {
          throw new TRPCError({ code: "UNAUTHORIZED", message: "Usuário não autenticado" });
        }
        
        const addressing = await import("./addressing");
        const result = await addressing.addressItem({
          ...input,
          addressedBy: ctx.user.id,
        });
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "address_receiving_item",
          entityType: "receiving_order_item",
          entityId: input.receivingOrderItemId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    getPendingAddressingBalance: protectedProcedure
      .input(z.object({ receivingOrderItemId: z.number() }))
      .query(async ({ input }) => {
        const addressing = await import("./addressing");
        return await addressing.getPendingAddressingBalance(input.receivingOrderItemId);
      }),
  }),

  // ============================================================================
  // PICKING
  // ============================================================================
  
  picking: router({
    list: protectedProcedure.query(async () => {
      return await picking.getAllPickingOrders();
    }),
    
    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        return await picking.getPickingOrderById(input.id);
      }),
    
    getItems: protectedProcedure
      .input(z.object({ pickingOrderId: z.number() }))
      .query(async ({ input }) => {
        return await picking.getPickingOrderItems(input.pickingOrderId);
      }),
    
    create: protectedProcedure
      .input(z.object({
        tenantId: z.number(),
        orderNumber: z.string().min(1),
        customerName: z.string().optional(),
        deliveryAddress: z.string().optional(),
        priority: z.enum(["emergency", "urgent", "normal", "low"]).default("normal"),
        items: z.array(z.object({
          productId: z.number(),
          requestedQuantity: z.number().min(1),
        })),
      }))
      .mutation(async ({ input, ctx }) => {
        const { items, ...orderData } = input;
        
        // Criar ordem de picking
        const result = await picking.createPickingOrder({
          ...orderData,
          createdBy: ctx.user.id,
        });
        
        const orderId = Number((result as any)[0]?.insertId || (result as any).insertId) || 0;
        
        if (!orderId) {
          throw new TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Falha ao criar ordem de picking",
          });
        }
        
        // Criar itens
        for (const item of items) {
          await picking.createPickingOrderItem({
            pickingOrderId: orderId,
            productId: item.productId,
            requestedQuantity: item.requestedQuantity,
          });
        }
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_picking_order",
          entityType: "picking_order",
          entityId: orderId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, id: orderId };
      }),
    
    startPicking: protectedProcedure
      .input(z.object({ pickingOrderId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const result = await picking.startPicking(input.pickingOrderId, ctx.user.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "start_picking",
          entityType: "picking_order",
          entityId: input.pickingOrderId,
          newValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true, ...result };
      }),
    
    confirmPicking: protectedProcedure
      .input(z.object({
        itemId: z.number(),
        pickedQuantity: z.number(),
        batch: z.string(),
        expiryDate: z.date(),
        serialNumber: z.string().optional(),
        fromLocationId: z.number(),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await picking.confirmPicking(
          input.itemId,
          input.pickedQuantity,
          input.batch,
          input.expiryDate,
          input.serialNumber,
          input.fromLocationId,
          ctx.user.id
        );
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "confirm_picking",
          entityType: "picking_order_item",
          entityId: input.itemId,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    finishPicking: protectedProcedure
      .input(z.object({ pickingOrderId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const result = await picking.finishPicking(input.pickingOrderId, ctx.user.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "finish_picking",
          entityType: "picking_order",
          entityId: input.pickingOrderId,
          newValue: JSON.stringify({ status: "picked" }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    delete: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await picking.getPickingOrderById(input.id);
        
        await picking.deletePickingOrder(input.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_picking_order",
          entityType: "picking_order",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),

    // Novos endpoints para fluxo de separação com bipagem
    importOrders: protectedProcedure
      .input(z.object({
        fileBase64: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        try {
          const { importPickingOrders } = await import('./picking-import');
          const fileBuffer = Buffer.from(input.fileBase64, 'base64');
          const result = await importPickingOrders(fileBuffer, ctx.user.id);
          
          if (result.success) {
            await db.createAuditLog({
              userId: ctx.user.id,
              action: "import_picking_orders",
              entityType: "picking_order",
              entityId: 0,
              newValue: JSON.stringify({ ordersCreated: result.ordersCreated, itemsCreated: result.itemsCreated }),
              ipAddress: ctx.req.ip,
              userAgent: ctx.req.headers["user-agent"],
            });
          }
          
          return result;
        } catch (error: any) {
          console.error('[picking.importOrders] Erro não tratado:', error);
          return {
            success: false,
            message: `Erro ao processar arquivo: ${error.message || 'Erro desconhecido'}`,
            errors: [error.stack || error.toString()]
          };
        }
      }),
    
    downloadTemplate: protectedProcedure
      .query(async () => {
        const { generatePickingTemplate } = await import('./picking-import');
        const buffer = generatePickingTemplate();
        return {
          data: buffer.toString('base64'),
          filename: 'modelo-ots-separacao.xlsx'
        };
      }),
    
    startSession: protectedProcedure
      .input(z.object({ orderId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const { startPickingSession } = await import('./picking-operations');
        const result = await startPickingSession(input.orderId, ctx.user.id);
        
        if (result.success) {
          await db.createAuditLog({
            userId: ctx.user.id,
            action: "start_picking_session",
            entityType: "picking_order",
            entityId: input.orderId,
            ipAddress: ctx.req.ip,
            userAgent: ctx.req.headers["user-agent"],
          });
        }
        
        return result;
      }),
    
    validateLocation: protectedProcedure
      .input(z.object({
        locationCode: z.string(),
        expectedLocationId: z.number(),
      }))
      .mutation(async ({ input }) => {
        const { validateLocationScan } = await import('./picking-operations');
        return await validateLocationScan(input.locationCode, input.expectedLocationId);
      }),
    
    scanLabel: protectedProcedure
      .input(z.object({
        labelCode: z.string(),
        itemId: z.number(),
        productId: z.number(),
        batch: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { processLabelScan } = await import('./picking-operations');
        return await processLabelScan(
          input.labelCode,
          input.itemId,
          input.productId,
          input.batch,
          ctx.user.id
        );
      }),
    
    bindLabel: protectedProcedure
      .input(z.object({
        labelCode: z.string(),
        productId: z.number(),
        batch: z.string(),
        expiryDate: z.date().nullable(),
        unitsPerLabel: z.number().min(1),
      }))
      .mutation(async ({ input, ctx }) => {
        const { bindLabelToProduct } = await import('./picking-operations');
        return await bindLabelToProduct(
          input.labelCode,
          input.productId,
          input.batch,
          input.expiryDate,
          input.unitsPerLabel,
          ctx.user.id
        );
      }),
    
    confirmPickingComplete: protectedProcedure
      .input(z.object({ orderId: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const { confirmPicking } = await import('./picking-operations');
        const result = await confirmPicking(input.orderId, ctx.user.id);
        
        if (result.success) {
          await db.createAuditLog({
            userId: ctx.user.id,
            action: "confirm_picking_complete",
            entityType: "picking_order",
            entityId: input.orderId,
            newValue: JSON.stringify({ status: 'picked' }),
            ipAddress: ctx.req.ip,
            userAgent: ctx.req.headers["user-agent"],
          });
        }
        
        return result;
      }),

    deleteMany: protectedProcedure
      .input(z.object({ ids: z.array(z.number()) }))
      .mutation(async ({ input, ctx }) => {
        let deletedCount = 0;
        for (const id of input.ids) {
          try {
            const oldValue = await picking.getPickingOrderById(id);
            await picking.deletePickingOrder(id);
            
            await db.createAuditLog({
              userId: ctx.user.id,
              action: "delete_picking_order",
              entityType: "picking_order",
              entityId: id,
              oldValue: JSON.stringify(oldValue),
              ipAddress: ctx.req.ip,
              userAgent: ctx.req.headers["user-agent"],
            });
            deletedCount++;
          } catch (error) {
            console.error(`Erro ao deletar ordem de picking ${id}:`, error);
          }
        }
        
        return { success: true, deletedCount };
      }),
  }),

  // ============================================================================
  // INVENTORY
  // ============================================================================
  
  inventory: router({
    list: protectedProcedure
      .input(z.object({ tenantId: z.number().optional() }).optional())
      .query(async ({ input }) => {
        return await db.getInventory(input?.tenantId);
      }),
    
    listPositions: protectedProcedure
      .input(z.object({ tenantId: z.number().optional() }).optional())
      .query(async ({ input }) => {
        const dbInstance = await getDb();
        if (!dbInstance) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database not available' });
        const result = await dbInstance
          .select({
            id: inventory.id,
            quantity: inventory.quantity,
            batch: inventory.batch,
            expiryDate: inventory.expiryDate,
            product: {
              id: products.id,
              sku: products.sku,
              description: products.description,
            },
            locationId: inventory.locationId,
            locationCode: warehouseLocations.code,
          })
          .from(inventory)
          .leftJoin(products, eq(inventory.productId, products.id))
          .leftJoin(warehouseLocations, eq(inventory.locationId, warehouseLocations.id))
          .where(input?.tenantId ? eq(products.tenantId, input.tenantId) : sql`1=1`)
          .orderBy(products.sku);
        return result;
      }),
    
    exportReport: protectedProcedure
      .input(z.object({
        includeEmptyLocations: z.boolean().default(false),
      }))
      .mutation(async ({ input, ctx }) => {
        const { generateInventoryReport } = await import('./inventory-export');
        const buffer = await generateInventoryReport({
          includeEmptyLocations: input.includeEmptyLocations,
        });
        
        // Registrar auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: 'export_inventory_report',
          entityType: 'inventory',
          newValue: JSON.stringify({ includeEmptyLocations: input.includeEmptyLocations }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        // Retornar buffer como base64 para transmissão
        return {
          filename: `posicao_estoque_${new Date().toISOString().split('T')[0]}.xlsx`,
          data: buffer.toString('base64'),
        };
      }),
  }),

  // ============================================================================
  // AUDIT LOGS
  // ============================================================================
  
  auditLogs: router({
    list: protectedProcedure
      .input(z.object({ 
        tenantId: z.number().optional(),
        limit: z.number().default(100)
      }).optional())
      .query(async ({ input }) => {
        return await db.getAuditLogs(input?.tenantId, input?.limit);
      }),
  }),

  // ============================================================================
  // LOCATIONS (ENDEREÇOS)
  // ============================================================================
  
  locations: router({
    list: protectedProcedure
      .input(z.object({
        zoneId: z.number().optional(),
        status: z.string().optional(),
        locationType: z.string().optional(),
        search: z.string().optional(),
        tenantId: z.number().optional().nullable(),
      }).optional())
      .query(async ({ input }) => {
        return await locations.listLocations(input || {});
      }),
    
    listWithStock: protectedProcedure
      .input(z.object({
        tenantId: z.number().optional().nullable(),
      }).optional())
      .query(async ({ input }) => {
        return await locations.listLocationsWithStock(input || {});
      }),
    
    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        return await locations.getLocationById(input.id);
      }),
    
    getCompatibleLocations: protectedProcedure
      .input(z.object({
        productId: z.number(),
        batch: z.string().optional().nullable(),
        tenantId: z.number().optional().nullable(),
      }))
      .query(async ({ input }) => {
        return await locations.getCompatibleLocations(input);
      }),
    
    create: protectedProcedure
      .input(z.object({
        zoneId: z.number(),
        tenantId: z.number(), // Cliente dono do endereço (OBRIGATÓRIO)
        aisle: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Rua deve conter apenas letras e números"), // Rua (OBRIGATÓRIO, 1-6 caracteres alfanuméricos)
        rack: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Prédio deve conter apenas letras e números"), // Prédio (OBRIGATÓRIO, 1-6 caracteres alfanuméricos)
        level: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Andar deve conter apenas letras e números").optional(), // Andar (OPCIONAL, 1-6 caracteres alfanuméricos)
        position: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Quadrante deve conter apenas letras e números").optional(), // Quadrante (OPCIONAL, 1-6 caracteres alfanuméricos)
        locationType: z.enum(["whole", "fraction"]), // Inteira ou Fração (OBRIGATÓRIO)
        storageRule: z.enum(["single", "multi"]), // Único item/lote ou Multi-item (OBRIGATÓRIO)
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await locations.createLocation(input);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_location",
          entityType: "location",
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        data: z.object({
          zoneId: z.number().optional(),
          tenantId: z.number().optional().nullable(), // Cliente dono do endereço
          aisle: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Rua deve conter apenas letras e números").optional(), // Rua (1-6 caracteres alfanuméricos)
          rack: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Prédio deve conter apenas letras e números").optional(), // Prédio (1-6 caracteres alfanuméricos)
          level: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Andar deve conter apenas letras e números").optional(), // Andar (1-6 caracteres alfanuméricos)
          position: z.string().min(1).max(6).regex(/^[A-Za-z0-9]+$/, "Quadrante deve conter apenas letras e números").optional(), // Quadrante (1-6 caracteres alfanuméricos)
          locationType: z.enum(["whole", "fraction"]).optional(), // Inteira ou Fracao
          storageRule: z.enum(["single", "multi"]).optional(), // Unico item/lote ou Multi-item
          status: z.enum(["available", "occupied", "blocked", "counting"]).optional(),
        }),
      }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await locations.getLocationById(input.id);
        
        const updated = await locations.updateLocation(input.id, input.data);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "update_location",
          entityType: "location",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          newValue: JSON.stringify(input.data),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return updated;
      }),
    
    delete: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await locations.getLocationById(input.id);
        
        await locations.deleteLocation(input.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_location",
          entityType: "location",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),

    deleteMany: protectedProcedure
      .input(z.object({ ids: z.array(z.number()) }))
      .mutation(async ({ input, ctx }) => {
        let deletedCount = 0;
        for (const id of input.ids) {
          try {
            const oldValue = await locations.getLocationById(id);
            await locations.deleteLocation(id);
            
            await db.createAuditLog({
              userId: ctx.user.id,
              action: "delete_location",
              entityType: "location",
              entityId: id,
              oldValue: JSON.stringify(oldValue),
              ipAddress: ctx.req.ip,
              userAgent: ctx.req.headers["user-agent"],
            });
            deletedCount++;
          } catch (error) {
            console.error(`Erro ao deletar endereço ${id}:`, error);
          }
        }
        
        return { success: true, deletedCount };
      }),
    
    listZones: protectedProcedure.query(async () => {
      return await locations.listZones();
    }),
    
    createZone: protectedProcedure
      .input(z.object({
        warehouseId: z.number(),
        code: z.string().min(1).max(50),
        name: z.string().min(1).max(255),
        storageCondition: z.enum(["ambient", "refrigerated_2_8", "frozen_minus_20", "controlled", "quarantine"]).default("ambient"),
        status: z.enum(["active", "inactive"]).default("active"),
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await locations.createZone(input);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_zone",
          entityType: "zone",
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    updateZone: protectedProcedure
      .input(z.object({
        id: z.number(),
        data: z.object({
          code: z.string().min(1).max(50).optional(),
          name: z.string().min(1).max(255).optional(),
          storageCondition: z.enum(["ambient", "refrigerated_2_8", "frozen_minus_20", "controlled", "quarantine"]).optional(),
          status: z.enum(["active", "inactive"]).optional(),
        }),
      }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await locations.getZoneById(input.id);
        const result = await locations.updateZone(input.id, input.data);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "update_zone",
          entityType: "zone",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          newValue: JSON.stringify(input.data),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    deleteZone: protectedProcedure
      .input(z.object({ id: z.number() }))
      .mutation(async ({ input, ctx }) => {
        const oldValue = await locations.getZoneById(input.id);
        await locations.deleteZone(input.id);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "delete_zone",
          entityType: "zone",
          entityId: input.id,
          oldValue: JSON.stringify(oldValue),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return { success: true };
      }),
    
    listWarehouses: protectedProcedure.query(async () => {
      return await locations.listWarehouses();
    }),
    
    createBulk: protectedProcedure
      .input(z.object({
        zoneId: z.number(),
        tenantId: z.number(), // Cliente dono dos endereços (OBRIGATÓRIO)
        aisle: z.string().min(1).max(6), // Rua fixa (OBRIGATÓRIO, 1-6 caracteres alfanuméricos)
        rackStart: z.string().min(1).max(6), // Prédio inicial (OBRIGATÓRIO, 1-6 caracteres alfanuméricos)
        rackEnd: z.string().min(1).max(6), // Prédio final (OBRIGATÓRIO, 1-6 caracteres alfanuméricos)
        levelStart: z.string().min(1).max(6).optional(), // Andar inicial (OPCIONAL, 1-6 caracteres alfanuméricos)
        levelEnd: z.string().min(1).max(6).optional(), // Andar final (OPCIONAL, 1-6 caracteres alfanuméricos)
        positions: z.array(z.string()).optional(), // Quadrantes (OPCIONAL)
        locationType: z.enum(["whole", "fraction"]), // Tipo (OBRIGATÓRIO)
        storageRule: z.enum(["single", "multi"]), // Regra de armazenagem (OBRIGATÓRIO)
      }))
      .mutation(async ({ input, ctx }) => {
        const result = await locations.createBulkLocations(input);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "create_bulk_locations",
          entityType: "location",
          newValue: JSON.stringify({ ...input, result }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    importFromExcel: protectedProcedure
      .input(z.object({
        fileBase64: z.string(), // Arquivo Excel em base64
      }))
      .mutation(async ({ input, ctx }) => {
        const { importLocationsFromExcel } = await import("./locations-import");
        
        // Converter base64 para buffer
        const fileBuffer = Buffer.from(input.fileBase64, 'base64');
        
        // Importar endereços
        const result = await importLocationsFromExcel(fileBuffer);
        
        // Registrar log de auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "import_locations_excel",
          entityType: "location",
          newValue: JSON.stringify({ total: result.total, created: result.created, skipped: result.skipped }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    downloadTemplate: protectedProcedure
      .query(async () => {
        const { generateTemplateExcel } = await import("./locations-import");
        
        // Gerar arquivo modelo
        const buffer = generateTemplateExcel();
        
        // Converter para base64 para enviar ao frontend
        const base64 = buffer.toString('base64');
        
        return { fileBase64: base64, filename: 'modelo_importacao_enderecos.xlsx' };
      }),
  }),

  divergenceApprovals: router({
    requestApproval: protectedProcedure
      .input(z.object({
        receivingOrderItemId: z.number(),
        divergenceType: z.enum(["quantity", "code_mismatch", "expiry_date", "multiple"]),
        divergenceDetails: z.object({
          expectedQuantity: z.number().optional(),
          receivedQuantity: z.number().optional(),
          expectedGtin: z.string().optional(),
          scannedGtin: z.string().optional(),
          expectedSupplierCode: z.string().optional(),
          scannedSupplierCode: z.string().optional(),
          expectedInternalCode: z.string().optional(),
          scannedInternalCode: z.string().optional(),
          expectedExpiryDate: z.string().optional(),
          scannedExpiryDate: z.string().optional(),
        }),
        justification: z.string().min(10, "Justificativa deve ter no mínimo 10 caracteres"),
      }))
      .mutation(async ({ input, ctx }) => {
        const approvalId = await divergenceApprovalsDb.createDivergenceApprovalRequest({
          receivingOrderItemId: input.receivingOrderItemId,
          requestedBy: ctx.user.id,
          divergenceType: input.divergenceType,
          divergenceDetails: input.divergenceDetails,
          justification: input.justification,
        });

        // Atualizar status do item para awaiting_approval
        await receiving.updateReceivingOrderItem(input.receivingOrderItemId, {
          status: "awaiting_approval",
        });

        // Registrar log de auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "request_divergence_approval",
          entityType: "receiving_order_item",
          entityId: input.receivingOrderItemId,
        });

        return { success: true, approvalId };
      }),

    approve: protectedProcedure
      .input(z.object({
        approvalId: z.number(),
        justification: z.string().min(10, "Justificativa deve ter no mínimo 10 caracteres"),
      }))
      .mutation(async ({ input, ctx }) => {
        // Verificar se usuário é admin/supervisor
        if (ctx.user.role !== "admin") {
          throw new TRPCError({
            code: "FORBIDDEN",
            message: "Apenas supervisores podem aprovar divergências",
          });
        }

        await divergenceApprovalsDb.approveDivergence(
          input.approvalId,
          ctx.user.id,
          input.justification
        );

        // Registrar log de auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "approve_divergence",
          entityType: "divergence_approval",
          entityId: input.approvalId,
        });

        return { success: true };
      }),

    reject: protectedProcedure
      .input(z.object({
        approvalId: z.number(),
        justification: z.string().min(10, "Justificativa deve ter no mínimo 10 caracteres"),
      }))
      .mutation(async ({ input, ctx }) => {
        // Verificar se usuário é admin/supervisor
        if (ctx.user.role !== "admin") {
          throw new TRPCError({
            code: "FORBIDDEN",
            message: "Apenas supervisores podem rejeitar divergências",
          });
        }

        await divergenceApprovalsDb.rejectDivergence(
          input.approvalId,
          ctx.user.id,
          input.justification
        );

        // Registrar log de auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "reject_divergence",
          entityType: "divergence_approval",
          entityId: input.approvalId,
        });

        return { success: true };
      }),

    getPending: protectedProcedure.query(async () => {
      const approvals = await divergenceApprovalsDb.getPendingApprovals();
      return approvals;
    }),

    getById: protectedProcedure
      .input(z.object({ approvalId: z.number() }))
      .query(async ({ input }) => {
        const approval = await divergenceApprovalsDb.getApprovalById(input.approvalId);
        return approval;
      }),
  }),

  // ============================================================================
  // ROUTER: ESTOQUE
  // ============================================================================

  stock: router({
    // Consultar posições de estoque
    getPositions: protectedProcedure
      .input(z.object({
        productId: z.number().optional(),
        locationId: z.number().optional(),
        zoneId: z.number().optional(),
        batch: z.string().optional(),
        status: z.enum(["available", "quarantine", "blocked", "damaged", "expired"]).optional(),
        minQuantity: z.number().optional(),
        search: z.string().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const inventoryDb = await import("./inventory");
        // Admin (tenantId null) pode ver todos os registros
        // Usuários normais veem apenas do seu tenant
        const filters: any = { ...input };
        if (ctx.user.tenantId !== null) {
          filters.tenantId = ctx.user.tenantId;
        }
        const positions = await inventoryDb.getInventoryPositions(filters);
        return positions;
      }),

    // Obter saldo total de um produto
    getProductStock: protectedProcedure
      .input(z.object({ productId: z.number() }))
      .query(async ({ input, ctx }) => {
        const inventoryDb = await import("./inventory");
        // Admin (tenantId null) vê estoque total de todos os tenants
        // Usuários normais veem apenas do seu tenant
        const tenantFilter = ctx.user.tenantId !== null ? ctx.user.tenantId : undefined;
        const total = await inventoryDb.getProductTotalStock(
          input.productId,
          tenantFilter
        );
        return { total };
      }),

    // Obter produtos com estoque baixo
    getLowStock: protectedProcedure
      .input(z.object({ threshold: z.number().default(10) }))
      .query(async ({ input, ctx }) => {
        if (!ctx.user.tenantId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Usuário sem tenant associado",
          });
        }
        const inventoryDb = await import("./inventory");
        const products = await inventoryDb.getLowStockProducts(
          ctx.user.tenantId,
          input.threshold
        );
        return products;
      }),

    // Sincronizar saldos de inventário
    syncInventory: protectedProcedure
      .mutation(async ({ ctx }) => {
        const inventorySync = await import("./inventory-sync");
        const result = await inventorySync.recalculateInventoryBalances();
        return result;
      }),

    // Obter produtos próximos ao vencimento
    getExpiring: protectedProcedure
      .input(z.object({ daysUntilExpiry: z.number().default(30) }))
      .query(async ({ input, ctx }) => {
        if (!ctx.user.tenantId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Usuário sem tenant associado",
          });
        }
        const inventoryDb = await import("./inventory");
        const products = await inventoryDb.getExpiringProducts(
          ctx.user.tenantId,
          input.daysUntilExpiry
        );
        return products;
      }),

    // Buscar endereço sugerido para produto
    getSuggestedLocation: protectedProcedure
      .input(z.object({ productId: z.number() }))
      .query(async ({ input, ctx }) => {
        const db = await import("./db");
        const dbConn = await db.getDb();
        if (!dbConn) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database connection failed" });
        
        const { productLocationMapping, warehouseLocations } = await import("../drizzle/schema");
        const { eq, and } = await import("drizzle-orm");
        
        // Buscar mapeamento ativo com maior prioridade
        const [mapping] = await dbConn
          .select({
            id: productLocationMapping.id,
            locationId: productLocationMapping.suggestedLocationId,
            locationCode: warehouseLocations.code,
          })
          .from(productLocationMapping)
          .leftJoin(warehouseLocations, eq(productLocationMapping.suggestedLocationId, warehouseLocations.id))
          .where(
            and(
              eq(productLocationMapping.productId, input.productId),
              eq(productLocationMapping.active, true),
              ctx.user.tenantId ? eq(productLocationMapping.tenantId, ctx.user.tenantId) : undefined
            )
          )
          .orderBy(productLocationMapping.priority)
          .limit(1);
        
        return mapping || null;
      }),
  }),

  stockMovements: router({
    // Registrar movimentação
    register: protectedProcedure
      .input(z.object({
        productId: z.number(),
        batch: z.string().optional(),
        serialNumber: z.string().optional(),
        fromLocationId: z.number().optional(),
        toLocationId: z.number().optional(),
        quantity: z.number().positive(),
        movementType: z.enum(["receiving", "put_away", "picking", "transfer", "adjustment", "return", "disposal"]),
        referenceType: z.string().optional(),
        referenceId: z.number().optional(),
        notes: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const movementsDb = await import("./movements");
        const result = await movementsDb.registerMovement({
          tenantId: ctx.user.tenantId || null,
          ...input,
          performedBy: ctx.user.id,
        });
        console.log('[StockMovements] Movimentação registrada com sucesso. ID:', result.movementId);
        return result;
      }),

    // Consultar histórico de movimentações
    getHistory: protectedProcedure
      .input(z.object({
        productId: z.number().optional(),
        movementType: z.enum(["receiving", "put_away", "picking", "transfer", "adjustment", "return", "disposal"]).optional(),
        fromLocationId: z.number().optional(),
        toLocationId: z.number().optional(),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
        performedBy: z.number().optional(),
      }))
      .query(async ({ input, ctx }) => {
        const movementsDb = await import("./movements");
        // Admin (tenantId null) vê todas as movimentações
        // Usuários normais veem apenas do seu tenant
        const filters: any = { ...input };
        if (ctx.user.tenantId !== null) {
          filters.tenantId = ctx.user.tenantId;
        }
        const history = await movementsDb.getMovementHistory(filters);
        return history;
      }),

    // Obter resumo de movimentações
    getSummary: protectedProcedure
      .input(z.object({
        startDate: z.date(),
        endDate: z.date(),
      }))
      .query(async ({ input, ctx }) => {
        if (!ctx.user.tenantId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Usuário sem tenant associado",
          });
        }
        const movementsDb = await import("./movements");
        const summary = await movementsDb.getMovementSummary(
          ctx.user.tenantId,
          input.startDate,
          input.endDate
        );
        return summary;
      }),

    // Transferência entre endereços
    transfer: protectedProcedure
      .input(z.object({
        productId: z.number(),
        batch: z.string().optional(),
        fromLocationId: z.number(),
        toLocationId: z.number(),
        quantity: z.number().positive(),
        notes: z.string().optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user.tenantId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Usuário sem tenant associado",
          });
        }
        const movementsDb = await import("./movements");
        const result = await movementsDb.transferStock({
          tenantId: ctx.user.tenantId,
          ...input,
          performedBy: ctx.user.id,
        });
        return result;
      }),
  }),

  stockCount: router({
    // Iniciar contagem
    start: protectedProcedure
      .input(z.object({
        countType: z.enum(["full_blind", "cyclic", "spot"]),
        scheduledDate: z.date().optional(),
        zoneId: z.number().optional(),
        locationIds: z.array(z.number()).optional(),
        productIds: z.array(z.number()).optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        if (!ctx.user.tenantId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Usuário sem tenant associado",
          });
        }
        const countDb = await import("./inventoryCount");
        const result = await countDb.startInventoryCount({
          tenantId: ctx.user.tenantId,
          ...input,
          createdBy: ctx.user.id,
        });
        return result;
      }),

    // Registrar contagem de um item
    registerCount: protectedProcedure
      .input(z.object({
        countItemId: z.number(),
        countedQuantity: z.number().nonnegative(),
      }))
      .mutation(async ({ input, ctx }) => {
        const countDb = await import("./inventoryCount");
        const result = await countDb.registerCount({
          ...input,
          countedBy: ctx.user.id,
        });
        return result;
      }),

    // Aprovar ajuste de divergência
    approveAdjustment: protectedProcedure
      .input(z.object({
        countItemId: z.number(),
        adjustmentReason: z.string().min(10, "Justificativa deve ter no mínimo 10 caracteres"),
      }))
      .mutation(async ({ input, ctx }) => {
        if (ctx.user.role !== "admin") {
          throw new TRPCError({
            code: "FORBIDDEN",
            message: "Apenas supervisores podem aprovar ajustes",
          });
        }
        if (!ctx.user.tenantId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Usuário sem tenant associado",
          });
        }
        const countDb = await import("./inventoryCount");
        const result = await countDb.approveAdjustment({
          ...input,
          adjustedBy: ctx.user.id,
          tenantId: ctx.user.tenantId,
        });
        return result;
      }),

    // Finalizar contagem
    complete: protectedProcedure
      .input(z.object({ countId: z.number() }))
      .mutation(async ({ input }) => {
        const countDb = await import("./inventoryCount");
        const result = await countDb.completeInventoryCount(input.countId);
        return result;
      }),

    // Listar contagens
    list: protectedProcedure
      .input(z.object({
        status: z.enum(["scheduled", "in_progress", "completed", "cancelled"]).optional(),
        countType: z.enum(["full_blind", "cyclic", "spot"]).optional(),
      }))
      .query(async ({ input, ctx }) => {
        const countDb = await import("./inventoryCount");
        const counts = await countDb.getInventoryCounts({
          tenantId: ctx.user.tenantId ?? undefined,
          ...input,
        });
        return counts;
      }),

    // Obter itens de uma contagem
    getItems: protectedProcedure
      .input(z.object({ countId: z.number() }))
      .query(async ({ input }) => {
        const countDb = await import("./inventoryCount");
        const items = await countDb.getCountItems(input.countId);
        return items;
      }),
  }),

  // ============================================================================
  // CLEANUP (LIMPEZA AUTOMÁTICA)
  // ============================================================================
  
  cleanup: router({
    // Executar limpeza completa
    run: protectedProcedure
      .input(z.object({ daysToExpire: z.number().default(7) }).optional())
      .mutation(async ({ input, ctx }) => {
        const cleanup = await import("./cleanup");
        const result = await cleanup.runCleanup(input?.daysToExpire || 7);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "run_cleanup",
          entityType: "system",
          entityId: 0,
          newValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    // Cancelar apenas pré-alocações expiradas
    cancelExpiredPreallocations: protectedProcedure
      .input(z.object({ daysToExpire: z.number().default(7) }).optional())
      .mutation(async ({ input, ctx }) => {
        const cleanup = await import("./cleanup");
        const result = await cleanup.cancelExpiredPreallocations(input?.daysToExpire || 7);
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "cancel_expired_preallocations",
          entityType: "system",
          entityId: 0,
          newValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    // Limpar apenas registros órfãos
    cleanOrphans: protectedProcedure
      .mutation(async ({ ctx }) => {
        const cleanup = await import("./cleanup");
        const result = await cleanup.cleanOrphanRecords();
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "clean_orphan_records",
          entityType: "system",
          entityId: 0,
          newValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
  }),

  // ============================================================================
  // DASHBOARD DE OCUPAÇÃO
  // ============================================================================
  occupancy: router({
    // Métricas gerais do armazém
    getWarehouseMetrics: protectedProcedure
      .query(async () => {
        const occupancy = await import("./occupancy");
        return await occupancy.getWarehouseOccupancyMetrics();
      }),
    
    // Ocupação por zona
    getByZone: protectedProcedure
      .query(async () => {
        const occupancy = await import("./occupancy");
        return await occupancy.getOccupancyByZone();
      }),
    
    // Zonas com capacidade crítica
    getCriticalZones: protectedProcedure
      .query(async () => {
        const occupancy = await import("./occupancy");
        return await occupancy.getCriticalCapacityZones();
      }),
    
    // Distribuição por tipo de endereço
    getLocationTypeDistribution: protectedProcedure
      .query(async () => {
        const occupancy = await import("./occupancy");
        return await occupancy.getLocationTypeDistribution();
      }),
    
    // Ocupação por cliente
    getByTenant: protectedProcedure
      .query(async () => {
        const occupancy = await import("./occupancy");
        return await occupancy.getOccupancyByTenant();
      }),
    
    // Sugestões inteligentes de otimização
    getOptimizationSuggestions: protectedProcedure
      .query(async () => {
        const optimization = await import("./optimization");
        return await optimization.generateOptimizationSuggestions();
      }),
  }),

  // ============================================================================
  // CONFERÊNCIA CEGA POR ASSOCIAÇÃO DE ETIQUETAS
  // ============================================================================
  blindConference: router({
    // Iniciar sessão de conferência cega
    start: protectedProcedure
      .input(z.object({
        receivingOrderId: z.number(),
      }))
      .mutation(async ({ input, ctx }) => {
        const blindConf = await import("./blindConference");
        const result = await blindConf.startBlindConference({
          receivingOrderId: input.receivingOrderId,
          tenantId: ctx.user.tenantId || 0,
          userId: ctx.user.id,
        });
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "start_blind_conference",
          entityType: "receiving_order",
          entityId: input.receivingOrderId,
          newValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    // Ler etiqueta
    readLabel: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
        labelCode: z.string(),
      }))
      .mutation(async ({ input, ctx }) => {
        const blindConf = await import("./blindConference");
        return await blindConf.readLabel({
          sessionId: input.sessionId,
          labelCode: input.labelCode,
          userId: ctx.user.id,
        });
      }),
    
    // Associar etiqueta a produto
    associateLabel: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
        labelCode: z.string(),
        productId: z.number(),
        batch: z.string().nullable(),
        expiryDate: z.string().nullable(),
        unitsPerPackage: z.number().positive(),
      }))
      .mutation(async ({ input, ctx }) => {
        const blindConf = await import("./blindConference");
        const result = await blindConf.associateLabel({
          ...input,
          userId: ctx.user.id,
        });
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "associate_label",
          entityType: "blind_conference",
          entityId: input.sessionId,
          newValue: JSON.stringify({ labelCode: input.labelCode, productId: input.productId }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    // Desfazer última leitura
    undoLastReading: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
      }))
      .mutation(async ({ input, ctx }) => {
        const blindConf = await import("./blindConference");
        const result = await blindConf.undoLastReading({
          sessionId: input.sessionId,
          userId: ctx.user.id,
        });
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "undo_blind_conference_reading",
          entityType: "blind_conference",
          entityId: input.sessionId,
          oldValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    // Ajustar quantidade manualmente
    adjustQuantity: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
        associationId: z.number(),
        newQuantity: z.number().nonnegative(),
        reason: z.string().nullable(),
      }))
      .mutation(async ({ input, ctx }) => {
        const blindConf = await import("./blindConference");
        const result = await blindConf.adjustQuantity({
          ...input,
          userId: ctx.user.id,
        });
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "adjust_blind_conference_quantity",
          entityType: "blind_conference",
          entityId: input.sessionId,
          oldValue: String(result.previousQuantity),
          newValue: String(result.newQuantity),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
    
    // Obter resumo da sessão
    getSummary: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
      }))
      .query(async ({ input }) => {
        const blindConf = await import("./blindConference");
        return await blindConf.getSessionSummary(input.sessionId);
      }),
    
    // Finalizar sessão
    finish: protectedProcedure
      .input(z.object({
        sessionId: z.number(),
      }))
      .mutation(async ({ input, ctx }) => {
        const blindConf = await import("./blindConference");
        const result = await blindConf.finishBlindConference({
          sessionId: input.sessionId,
          userId: ctx.user.id,
        });
        
        await db.createAuditLog({
          userId: ctx.user.id,
          action: "finish_blind_conference",
          entityType: "blind_conference",
          entityId: input.sessionId,
          newValue: JSON.stringify(result),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers["user-agent"],
        });
        
        return result;
      }),
  }),

  // ============================================================================
  // USUÁRIOS E PERMISSÕES (RBAC)
  // ============================================================================
  
  users: router({
    // Listar usuários do tenant
    list: protectedProcedure
      .input(z.object({ tenantId: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database connection failed' });
        
        const { systemUsers, userRoles, roles } = await import('../drizzle/schema');
        
        // Buscar usuários com seus perfis
        const users = await database
          .select({
            id: systemUsers.id,
            fullName: systemUsers.fullName,
            login: systemUsers.login,
            email: systemUsers.email,
            active: systemUsers.active,
            lastLogin: systemUsers.lastLogin,
            createdAt: systemUsers.createdAt,
          })
          .from(systemUsers)
          .where(eq(systemUsers.tenantId, input.tenantId));
        
        // Buscar perfis de cada usuário
        const usersWithRoles = await Promise.all(
          users.map(async (user) => {
            const userRolesList = await database
              .select({
                roleId: roles.id,
                roleCode: roles.code,
                roleName: roles.name,
                isPrimary: userRoles.isPrimary,
              })
              .from(userRoles)
              .innerJoin(roles, eq(userRoles.roleId, roles.id))
              .where(eq(userRoles.userId, user.id));
            
            return {
              ...user,
              roles: userRolesList,
            };
          })
        );
        
        return usersWithRoles;
      }),
    
    // Buscar usuário por ID
    getById: protectedProcedure
      .input(z.object({ id: z.number() }))
      .query(async ({ input }) => {
        const database = await getDb();
        if (!database) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Database connection failed' });
        
        const { systemUsers, userRoles, roles } = await import('../drizzle/schema');
        
        const [user] = await database
          .select()
          .from(systemUsers)
          .where(eq(systemUsers.id, input.id))
          .limit(1);
        
        if (!user) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Usuário não encontrado' });
        }
        
        // Buscar perfis
        const userRolesList = await database
          .select({
            roleId: roles.id,
            roleCode: roles.code,
            roleName: roles.name,
            isPrimary: userRoles.isPrimary,
          })
          .from(userRoles)
          .innerJoin(roles, eq(userRoles.roleId, roles.id))
          .where(eq(userRoles.userId, user.id));
        
        return {
          ...user,
          roles: userRolesList,
        };
      }),
    
    // Criar usuário
    create: protectedProcedure
      .input(z.object({
        tenantId: z.number(),
        fullName: z.string().min(1),
        login: z.string().min(3),
        email: z.string().email(),
        password: z.string().min(6),
        roleIds: z.array(z.number()).min(1),
      }))
      .mutation(async ({ input, ctx }) => {
        const { createUser } = await import('./rbac');
        
        const userId = await createUser({
          tenantId: input.tenantId,
          fullName: input.fullName,
          login: input.login,
          email: input.email,
          password: input.password,
          roleIds: input.roleIds,
          createdBy: ctx.user.id,
        });
        
        // Auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: 'create_user',
          entityType: 'systemUser',
          entityId: userId,
          newValue: JSON.stringify({ fullName: input.fullName, login: input.login, email: input.email }),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers['user-agent'],
        });
        
        return { success: true, userId };
      }),
    
    // Atualizar usuário
    update: protectedProcedure
      .input(z.object({
        id: z.number(),
        fullName: z.string().min(1).optional(),
        email: z.string().email().optional(),
        active: z.boolean().optional(),
        password: z.string().min(6).optional(),
        roleIds: z.array(z.number()).optional(),
      }))
      .mutation(async ({ input, ctx }) => {
        const { updateUser, updateUserRoles } = await import('./rbac');
        
        // Atualizar dados básicos
        await updateUser(input.id, {
          fullName: input.fullName,
          email: input.email,
          active: input.active,
          password: input.password,
        });
        
        // Atualizar perfis se fornecido
        if (input.roleIds) {
          await updateUserRoles(input.id, input.roleIds, ctx.user.id);
        }
        
        // Auditoria
        await db.createAuditLog({
          userId: ctx.user.id,
          action: 'update_user',
          entityType: 'systemUser',
          entityId: input.id,
          newValue: JSON.stringify(input),
          ipAddress: ctx.req.ip,
          userAgent: ctx.req.headers['user-agent'],
        });
        
        return { success: true };
      }),
    
    // Listar perfis disponíveis
    listRoles: protectedProcedure.query(async () => {
      const { listRoles } = await import('./rbac');
      return await listRoles();
    }),
    
    // Listar permissões disponíveis
    listPermissions: protectedProcedure.query(async () => {
      const { listPermissions } = await import('./rbac');
      return await listPermissions();
    }),
    
    // Buscar permissões efetivas de um usuário
    getUserPermissions: protectedProcedure
      .input(z.object({ userId: z.number() }))
      .query(async ({ input }) => {
        const { getUserEffectivePermissions } = await import('./rbac');
        return await getUserEffectivePermissions(input.userId);
      }),
  }),

});

export type AppRouter = typeof appRouter;
