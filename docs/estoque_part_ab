): Promise<number> {
  const dbConn = await getDb();
  if (!dbConn) throw new Error("Database connection failed");

  const conditions = [eq(inventory.locationId, locationId)];
  if (productId) conditions.push(eq(inventory.productId, productId));
  if (batch) conditions.push(eq(inventory.batch, batch));

  const result = await dbConn
    .select({ total: sql<number>`SUM(${inventory.quantity})` })
    .from(inventory)
    .where(and(...conditions));

  return result[0]?.total ?? 0;
}

/**
 * Obtém produtos com estoque abaixo do mínimo
 */
export async function getLowStockProducts(
  minQuantity: number = 10
): Promise<InventoryPosition[]> {
  return getInventoryPositions({ minQuantity });
}

/**
 * Obtém produtos próximos do vencimento
 */
export async function getExpiringProducts(
  daysThreshold: number = 30
): Promise<InventoryPosition[]> {
  const dbConn = await getDb();
  if (!dbConn) throw new Error("Database connection failed");

  const futureDate = new Date();
  futureDate.setDate(futureDate.getDate() + daysThreshold);

  const locationTenant = alias(tenants, 'locationTenant');

  const results = await dbConn
    .select({
      id: inventory.id,
      productId: inventory.productId,
      productSku: products.sku,
      productDescription: products.description,
      locationId: inventory.locationId,
      locationCode: warehouseLocations.code,
      locationStatus: warehouseLocations.status,
      zoneName: warehouseZones.name,
      batch: inventory.batch,
      expiryDate: inventory.expiryDate,
      quantity: inventory.quantity,
      status: inventory.status,
      tenantId: warehouseLocations.tenantId,
      tenantName: locationTenant.name,
      createdAt: inventory.createdAt,
      updatedAt: inventory.updatedAt,
    })
    .from(inventory)
    .innerJoin(products, eq(inventory.productId, products.id))
    .innerJoin(warehouseLocations, eq(inventory.locationId, warehouseLocations.id))
    .innerJoin(warehouseZones, eq(warehouseLocations.zoneId, warehouseZones.id))
    .leftJoin(locationTenant, eq(warehouseLocations.tenantId, locationTenant.id))
    .where(
      and(
        lte(inventory.expiryDate, futureDate),
        gt(inventory.expiryDate, new Date())
      )
    )
    .orderBy(inventory.expiryDate)
    .limit(1000);

  return results;
}
```

### server/movements.ts - Movimentações de Estoque

```typescript
import { eq, and, sum } from "drizzle-orm";
import { getDb } from "./db";
import {
  inventory,
  inventoryMovements,
  warehouseLocations,
  products,
} from "../drizzle/schema";
import { updateLocationStatus } from "./locations";

export interface RegisterMovementInput {
  productId: number;
  fromLocationId: number;
  toLocationId: number;
  quantity: number;
  batch?: string;
  movementType: "transfer" | "adjustment" | "return" | "disposal";
  notes?: string;
  tenantId?: number | null;
}

/**
 * Registra movimentação de estoque com validações
 */
export async function registerMovement(input: RegisterMovementInput) {
  const dbConn = await getDb();
  if (!dbConn) throw new Error("Database connection failed");

  // FASE 1: VALIDAÇÕES (sem modificar dados)
  
  // Validar saldo disponível na origem
  const fromStock = await dbConn
    .select({ total: sum(inventory.quantity) })
    .from(inventory)
    .where(
      and(
        eq(inventory.locationId, input.fromLocationId),
        eq(inventory.productId, input.productId),
        input.batch ? eq(inventory.batch, input.batch) : undefined
      )
    );

  const availableQuantity = fromStock[0]?.total ?? 0;
  if (availableQuantity < input.quantity) {
    throw new Error(
      `Saldo insuficiente. Disponível: ${availableQuantity}, Solicitado: ${input.quantity}`
    );
  }

  // Validar regra de armazenagem do endereço destino
  const toLocation = await dbConn
    .select()
    .from(warehouseLocations)
    .where(eq(warehouseLocations.id, input.toLocationId))
    .limit(1);

  if (!toLocation[0]) {
    throw new Error("Endereço destino não encontrado");
  }

  // Se endereço é "single" (único item/lote), validar se já contém outro produto/lote
  if (toLocation[0].storageRule === "single") {
    const existingStock = await dbConn
      .select()
      .from(inventory)
      .where(eq(inventory.locationId, input.toLocationId))
      .limit(1);

    if (existingStock.length > 0) {
      const existing = existingStock[0];
      if (
        existing.productId !== input.productId ||
        existing.batch !== input.batch
      ) {
        throw new Error(
          `Endereço ${toLocation[0].code} é de único item/lote e já contém outro produto/lote`
        );
      }
    }
  }

  // FASE 2: MODIFICAR DADOS (somente se validações passarem)

  // Deduzir estoque da origem
  const fromInventory = await dbConn
    .select()
    .from(inventory)
    .where(
      and(
        eq(inventory.locationId, input.fromLocationId),
        eq(inventory.productId, input.productId),
        input.batch ? eq(inventory.batch, input.batch) : undefined
      )
    )
    .limit(1);

  if (fromInventory[0]) {
    const newQuantity = fromInventory[0].quantity - input.quantity;
    if (newQuantity <= 0) {
      // Remover registro se quantidade chegar a zero
      await dbConn
        .delete(inventory)
        .where(eq(inventory.id, fromInventory[0].id));
    } else {
      // Atualizar quantidade
      await dbConn
        .update(inventory)
        .set({ quantity: newQuantity })
        .where(eq(inventory.id, fromInventory[0].id));
    }
  }

  // Adicionar estoque ao destino
  const toInventory = await dbConn
    .select()
    .from(inventory)
    .where(
      and(
        eq(inventory.locationId, input.toLocationId),
        eq(inventory.productId, input.productId),
        input.batch ? eq(inventory.batch, input.batch) : undefined
      )
    )
    .limit(1);

  if (toInventory[0]) {
    // Atualizar quantidade existente
    await dbConn
      .update(inventory)
      .set({
        quantity: toInventory[0].quantity + input.quantity,
        expiryDate: fromInventory[0]?.expiryDate,
      })
      .where(eq(inventory.id, toInventory[0].id));
  } else {
    // Criar novo registro
    await dbConn.insert(inventory).values({
      productId: input.productId,
      locationId: input.toLocationId,
      batch: input.batch,
      quantity: input.quantity,
      expiryDate: fromInventory[0]?.expiryDate,
      status: "available",
      tenantId: input.tenantId,
    });
  }

  // Registrar movimentação no histórico
  await dbConn.insert(inventoryMovements).values({
    productId: input.productId,
    fromLocationId: input.fromLocationId,
    toLocationId: input.toLocationId,
    quantity: input.quantity,
    batch: input.batch,
    movementType: input.movementType,
    notes: input.notes,
    createdAt: new Date(),
  });

  // Atualizar status dos endereços
  await updateLocationStatus(input.fromLocationId);
  await updateLocationStatus(input.toLocationId);

  return { success: true, message: "Movimentação registrada com sucesso" };
}

/**
 * Obtém histórico de movimentações
 */
export async function getMovementHistory(
  filters?: {
    productId?: number;
    locationId?: number;
    movementType?: string;
    startDate?: Date;
    endDate?: Date;
  }
): Promise<any[]> {
  const dbConn = await getDb();
  if (!dbConn) throw new Error("Database connection failed");

  const conditions = [];
  if (filters?.productId) {
    conditions.push(eq(inventoryMovements.productId, filters.productId));
  }
  if (filters?.movementType) {
    conditions.push(eq(inventoryMovements.movementType, filters.movementType));
  }

  const results = await dbConn
    .select({
      id: inventoryMovements.id,
      productId: inventoryMovements.productId,
      productSku: products.sku,
      fromLocationCode: warehouseLocations.code,
      toLocationCode: warehouseLocations.code,
      quantity: inventoryMovements.quantity,
      batch: inventoryMovements.batch,
      movementType: inventoryMovements.movementType,
      notes: inventoryMovements.notes,
      createdAt: inventoryMovements.createdAt,
    })
    .from(inventoryMovements)
    .innerJoin(products, eq(inventoryMovements.productId, products.id))
    .leftJoin(
      warehouseLocations,
      eq(inventoryMovements.fromLocationId, warehouseLocations.id)
    )
    .where(conditions.length > 0 ? and(...conditions) : undefined)
    .orderBy(desc(inventoryMovements.createdAt))
    .limit(500);

  return results;
}
```

### server/occupancy.ts - Dashboard de Ocupação

```typescript
import { getDb } from "./db";
import { warehouseZones, warehouseLocations, inventory } from "../drizzle/schema";
import { eq, sql } from "drizzle-orm";

export interface ZoneOccupancy {
  zoneId: number;
  zoneName: string;
  total: number;
  occupied: number;
  available: number;
  blocked: number;
  counting: number;
  occupancyPercentage: number;
}

/**
 * Calcula ocupação por zona
 */
export async function getOccupancyByZone(): Promise<ZoneOccupancy[]> {
  const dbConn = await getDb();
  if (!dbConn) throw new Error("Database connection failed");

  const zones = await dbConn
    .select({
      zoneId: warehouseZones.id,
      zoneName: warehouseZones.name,
      total: sql<number>`COUNT(DISTINCT ${warehouseLocations.id})`,
      occupied: sql<number>`COUNT(DISTINCT CASE WHEN ${inventory.quantity} > 0 THEN ${warehouseLocations.id} END)`,
      available: sql<number>`COUNT(DISTINCT CASE WHEN ${inventory.quantity} IS NULL OR ${inventory.quantity} = 0 THEN ${warehouseLocations.id} END)`,
      blocked: sql<number>`COUNT(DISTINCT CASE WHEN ${warehouseLocations.status} = 'blocked' THEN ${warehouseLocations.id} END)`,
      counting: sql<number>`COUNT(DISTINCT CASE WHEN ${warehouseLocations.status} = 'counting' THEN ${warehouseLocations.id} END)`,
    })
    .from(warehouseZones)
    .innerJoin(warehouseLocations, eq(warehouseLocations.zoneId, warehouseZones.id))
    .leftJoin(inventory, eq(inventory.locationId, warehouseLocations.id))
    .groupBy(warehouseZones.id, warehouseZones.name);

  return zones.map((z) => ({
    ...z,
    occupancyPercentage: z.total > 0 ? (z.occupied / z.total) * 100 : 0,
  }));
}

/**
 * Calcula ocupação geral do armazém
 */
export async function getOverallOccupancy() {
  const dbConn = await getDb();
  if (!dbConn) throw new Error("Database connection failed");

  const result = await dbConn
    .select({
      total: sql<number>`COUNT(DISTINCT ${warehouseLocations.id})`,
      occupied: sql<number>`COUNT(DISTINCT CASE WHEN ${inventory.quantity} > 0 THEN ${warehouseLocations.id} END)`,
      available: sql<number>`COUNT(DISTINCT CASE WHEN ${inventory.quantity} IS NULL OR ${inventory.quantity} = 0 THEN ${warehouseLocations.id} END)`,
      blocked: sql<number>`COUNT(DISTINCT CASE WHEN ${warehouseLocations.status} = 'blocked' THEN ${warehouseLocations.id} END)`,
      counting: sql<number>`COUNT(DISTINCT CASE WHEN ${warehouseLocations.status} = 'counting' THEN ${warehouseLocations.id} END)`,
    })
    .from(warehouseLocations)
    .leftJoin(inventory, eq(inventory.locationId, warehouseLocations.id));

  const data = result[0];
  return {
    ...data,
    occupancyPercentage: data.total > 0 ? (data.occupied / data.total) * 100 : 0,
  };
}
```

---

## Frontend - Código Completo

### client/src/pages/StockPositions.tsx

```typescript
import { useState } from "react";
import { useAuth } from "@/lib/useAuth";
import { trpc } from "@/lib/trpc";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { toast } from "sonner";
import { ArrowLeft, Home, Download, Package, Boxes, MapPin, AlertCircle } from "lucide-react";
import { useRouter } from "wouter";

export default function StockPositions() {
  const router = useRouter();
  const { user } = useAuth();
  const [searchTerm, setSearchTerm] = useState("");
  const [clientFilter, setClientFilter] = useState<string>("all");
  const [zoneFilter, setZoneFilter] = useState<string>("all");
  const [statusFilter, setStatusFilter] = useState<string>("all");
  const [batchFilter, setBatchFilter] = useState("");
  const [locationFilter, setLocationFilter] = useState("");

  // Queries
  const { data: positions = [], isLoading } = trpc.stock.getPositions.useQuery({
